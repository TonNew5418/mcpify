#!/usr/bin/env python3
"""
Generated MCP Server for {{ repository_name }} (STDIO Transport)
Auto-generated by MCPify from {{ repository_url }}
Uses official MCP SDK with STDIO transport for subprocess communication

IMPORTANT: This server uses STDIO transport and should be started by MCP clients,
not run directly. MCP clients will spawn this server as a subprocess and communicate
via stdin/stdout streams.

Usage by MCP clients:
- Claude Desktop: Add to config and it will be auto-spawned
- Other MCP clients: Use subprocess.Popen with stdin/stdout PIPE
"""

import asyncio
import sys
import importlib.util
from pathlib import Path
from typing import Any, Dict, List, Optional, Sequence

from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import (
    Tool,
    TextContent,
    CallToolRequest,
    CallToolResult,
    ListToolsRequest,
)

# Add repository to Python path
REPO_PATH = Path("{{ repository_path }}")
sys.path.insert(0, str(REPO_PATH))

# Add original project's virtual environment to Python path if it exists
VENV_PATH = REPO_PATH / ".mcpify_venv"
if VENV_PATH.exists():
    import site
    # Add the site-packages from original project's venv
    site_packages = VENV_PATH / "lib" / "python3.10" / "site-packages"  # Adjust version as needed
    if not site_packages.exists():
        # Try different Python versions
        for version_dir in (VENV_PATH / "lib").glob("python*"):
            site_packages = version_dir / "site-packages"
            if site_packages.exists():
                break

    if site_packages.exists():
        sys.path.insert(0, str(site_packages))

class MCPifyServer:
    """MCP Server using official SDK for {{ repository_name }} (STDIO Transport)."""

    def __init__(self):
        self.server = Server("{{ repository_name.lower().replace('_', '-') }}")
        self.tools_config = {{ tools_config | topython }}
        self.setup_imports()
        self.setup_tools()

    def setup_imports(self):
        """Import required modules and functions."""
        self.imported_functions = {}

        for tool in self.tools_config:
            impl = tool["implementation"]
            if impl["type"] == "python_function":
                try:
                    # Import the module
                    file_path = Path(impl["file_path"])
                    if file_path.exists():
                        spec = importlib.util.spec_from_file_location(
                            impl["module"], file_path
                        )
                        module = importlib.util.module_from_spec(spec)
                        spec.loader.exec_module(module)

                        # Get the function
                        if impl["class"]:
                            cls = getattr(module, impl["class"])
                            func = getattr(cls, impl["function"])
                            # For methods, we need to instantiate the class
                            # This is a simple approach - may need enhancement
                            self.imported_functions[tool["name"]] = lambda *args, **kwargs: func(cls(), *args, **kwargs)
                        else:
                            func = getattr(module, impl["function"])
                            self.imported_functions[tool["name"]] = func

                except Exception as e:
                    print(f"Failed to import {tool['name']}: {e}", file=sys.stderr)
                    self.imported_functions[tool["name"]] = None

    def setup_tools(self):
        """Setup MCP tools using the SDK."""

        # Register list_tools handler
        @self.server.list_tools()
        async def list_tools() -> List[Tool]:
            """List available tools."""
            tools = []
            for tool_config in self.tools_config:
                tool = Tool(
                    name=tool_config["name"],
                    description=tool_config["description"],
                    inputSchema=tool_config["inputSchema"]
                )
                tools.append(tool)
            return tools

        # Register call_tool handler
        @self.server.call_tool()
        async def call_tool(name: str, arguments: Dict[str, Any]) -> Sequence[TextContent]:
            """Call a specific tool."""

            if name not in self.imported_functions:
                raise ValueError(f"Tool not found: {name}")

            func = self.imported_functions[name]
            if func is None:
                raise RuntimeError(f"Tool {name} failed to import")

            try:
                # Call the function with arguments
                if asyncio.iscoroutinefunction(func):
                    result = await func(**arguments)
                else:
                    result = func(**arguments)

                # Convert result to string
                result_text = str(result)

                return [TextContent(type="text", text=result_text)]

            except Exception as e:
                error_msg = f"Tool execution failed: {str(e)}"
                raise RuntimeError(error_msg)

    async def run(self):
        """Run the MCP server using stdio transport."""
        print(f"MCPify STDIO Server for {{ repository_name }} started", file=sys.stderr)
        print("Available tools:", file=sys.stderr)
        for tool in self.tools_config:
            print(f"  - {tool['name']}: {tool['description']}", file=sys.stderr)

        # Run the server using stdio transport
        async with stdio_server() as (read_stream, write_stream):
            await self.server.run(
                read_stream,
                write_stream,
                self.server.create_initialization_options()
            )


async def main():
    """Main entry point."""
    server = MCPifyServer()
    await server.run()


if __name__ == "__main__":
    asyncio.run(main())
