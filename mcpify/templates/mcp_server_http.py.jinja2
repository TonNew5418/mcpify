#!/usr/bin/env python3
"""
Generated MCP Server for {{ repository_name }} (HTTP Transport)
Auto-generated by MCPify from {{ repository_url }}
Uses official MCP SDK with HTTP transport for web-based communication
"""

import asyncio
import sys
import importlib.util
from pathlib import Path
from typing import Any, Dict, List, Optional, Sequence

from mcp.server import Server
from mcp.types import (
    Tool,
    TextContent,
    CallToolRequest,
    CallToolResult,
    ListToolsRequest,
)

# Add repository to Python path
REPO_PATH = Path("{{ repository_path }}")
sys.path.insert(0, str(REPO_PATH))

# Add original project's virtual environment to Python path if it exists
VENV_PATH = REPO_PATH / ".mcpify_venv"
if VENV_PATH.exists():
    import site
    # Add the site-packages from original project's venv
    site_packages = VENV_PATH / "lib" / "python3.10" / "site-packages"  # Adjust version as needed
    if not site_packages.exists():
        # Try different Python versions
        for version_dir in (VENV_PATH / "lib").glob("python*"):
            site_packages = version_dir / "site-packages"
            if site_packages.exists():
                break

    if site_packages.exists():
        sys.path.insert(0, str(site_packages))

class MCPifyServer:
    """MCP Server using official SDK for {{ repository_name }} (HTTP Transport)."""

    def __init__(self):
        self.server = Server("{{ repository_name.lower().replace('_', '-') }}")
        self.tools_config = {{ tools_config | topython }}
        self.setup_imports()
        self.setup_tools()

    def setup_imports(self):
        """Import required modules and functions."""
        self.imported_functions = {}

        for tool in self.tools_config:
            impl = tool["implementation"]
            if impl["type"] == "python_function":
                try:
                    # Import the module
                    file_path = Path(impl["file_path"])
                    if file_path.exists():
                        spec = importlib.util.spec_from_file_location(
                            impl["module"], file_path
                        )
                        module = importlib.util.module_from_spec(spec)
                        spec.loader.exec_module(module)

                        # Get the function
                        if impl["class"]:
                            cls = getattr(module, impl["class"])
                            func = getattr(cls, impl["function"])
                            # For methods, we need to instantiate the class
                            # This is a simple approach - may need enhancement
                            self.imported_functions[tool["name"]] = lambda *args, **kwargs: func(cls(), *args, **kwargs)
                        else:
                            func = getattr(module, impl["function"])
                            self.imported_functions[tool["name"]] = func

                except Exception as e:
                    print(f"Failed to import {tool['name']}: {e}", file=sys.stderr)
                    self.imported_functions[tool["name"]] = None

    def setup_tools(self):
        """Setup MCP tools using the SDK."""

        # Register list_tools handler
        @self.server.list_tools()
        async def list_tools() -> List[Tool]:
            """List available tools."""
            tools = []
            for tool_config in self.tools_config:
                tool = Tool(
                    name=tool_config["name"],
                    description=tool_config["description"],
                    inputSchema=tool_config["inputSchema"]
                )
                tools.append(tool)
            return tools

        # Register call_tool handler
        @self.server.call_tool()
        async def call_tool(name: str, arguments: Dict[str, Any]) -> Sequence[TextContent]:
            """Call a specific tool."""

            if name not in self.imported_functions:
                raise ValueError(f"Tool not found: {name}")

            func = self.imported_functions[name]
            if func is None:
                raise RuntimeError(f"Tool {name} failed to import")

            try:
                # Call the function with arguments
                if asyncio.iscoroutinefunction(func):
                    result = await func(**arguments)
                else:
                    result = func(**arguments)

                # Convert result to string
                result_text = str(result)

                return [TextContent(type="text", text=result_text)]

            except Exception as e:
                error_msg = f"Tool execution failed: {str(e)}"
                raise RuntimeError(error_msg)

    async def run_http(self, host: str = "127.0.0.1", port: int = 8000):
        """Run the MCP server using HTTP transport."""
        print(f"MCPify HTTP Server for {{ repository_name }} starting on {host}:{port}", file=sys.stderr)
        print("Available tools:", file=sys.stderr)
        for tool in self.tools_config:
            print(f"  - {tool['name']}: {tool['description']}", file=sys.stderr)

        # TODO: Implement HTTP transport when MCP SDK adds support
        # For now, this is a placeholder for future HTTP implementation
        try:
            from fastapi import FastAPI
            from fastapi.responses import JSONResponse
            import uvicorn

            app = FastAPI(title=f"MCPify Server - {{ repository_name }}")

            @app.get("/health")
            async def health():
                return {"status": "healthy", "server": "{{ repository_name }}", "transport": "http"}

            @app.get("/tools")
            async def list_tools_http():
                tools = []
                for tool_config in self.tools_config:
                    tools.append({
                        "name": tool_config["name"],
                        "description": tool_config["description"],
                        "inputSchema": tool_config["inputSchema"]
                    })
                return {"tools": tools}

            @app.post("/tools/{tool_name}")
            async def call_tool_http(tool_name: str, arguments: Dict[str, Any]):
                if tool_name not in self.imported_functions:
                    return JSONResponse(
                        status_code=404,
                        content={"error": f"Tool not found: {tool_name}"}
                    )

                func = self.imported_functions[tool_name]
                if func is None:
                    return JSONResponse(
                        status_code=500,
                        content={"error": f"Tool {tool_name} failed to import"}
                    )

                try:
                    if asyncio.iscoroutinefunction(func):
                        result = await func(**arguments)
                    else:
                        result = func(**arguments)

                    return {"result": str(result)}
                except Exception as e:
                    return JSONResponse(
                        status_code=500,
                        content={"error": f"Tool execution failed: {str(e)}"}
                    )

            print(f"Starting HTTP server on http://{host}:{port}", file=sys.stderr)
            await uvicorn.Server(uvicorn.Config(app, host=host, port=port, log_level="info")).serve()

        except ImportError:
            print("Error: FastAPI and uvicorn are required for HTTP transport", file=sys.stderr)
            print("Install with: pip install fastapi uvicorn", file=sys.stderr)
            raise


async def main():
    """Main entry point."""
    import argparse
    parser = argparse.ArgumentParser(description="MCPify HTTP Server for {{ repository_name }}")
    parser.add_argument("--host", default="127.0.0.1", help="Host to bind to")
    parser.add_argument("--port", type=int, default=8000, help="Port to bind to")
    args = parser.parse_args()

    server = MCPifyServer()
    await server.run_http(host=args.host, port=args.port)


if __name__ == "__main__":
    asyncio.run(main())
